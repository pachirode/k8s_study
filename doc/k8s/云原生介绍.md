# 云计算

云计算会提供很多资源，基础资源（`CPU`，内存，网络等），还包括了其上搭建的各种应用

- 分类
    - 基础设施即服务
        - 通过虚拟化技术，动态提供基础计算资源，用户通过网络获取自己需要的计算资源
    - 平台即服务
        - 提供用于开发，测试和管理软件应用的平台（云函数，`API` 网关）
            - 应用程序平台
                - 支持应用程序在云端的开发和部署
            - 集成平台
                - 企业内部和跨部门数据集成方案
    - 软件
        - 提供提供网络访问的软件
    - 服务模型
        - 函数
        - 容器
        - 桌面
        - 后端
    - 部署模型
        - 公有云
        - 私有云
        - 社区云
        - 混合云

# 云原生

- 核心技术栈
    - 容器化
        - 以 `Kubernetes` 作为资源编排调度引擎，提供容器化的计算资源
    - 微服务
        - 软件架构思想，构建功能独立，可独立开发，部署，维护的云原生项目
            - `Spring Cloud`
            - `go-micro`
    - 服务网格
        - 建立在 `Kubernetes` 上，作为服务之间的通信的底座，提供服务治理能力
    - 声明式 `API`
        - 编程模型，只需要描述所需的结果，不需要详细指定如何实现
    - 不可变基础设施
        - 应用一旦被创建，只能重建不能更新
    - `DevOps`
        - 软件开发和运维方法实践
- 特点
    - 自动扩容
    - 自动发布
    - 高度自愈
    - 全方位观测
    - 开放标准和互操作

### 微服务

一种软件架构方式，使用微服务可以将一个大型应用按照功能模块拆分为多个独立自主的微服务，每个服务只实现一种功能，具有明确的边界
通常使用 `REST` `RPC` 标准接口进行通信和数据交换

- 优点
    - 简化复杂应用
        - 一个微服务只负责一项指定的业务
    - 简化应用部署
        - 可以对指定的组件进行构建，部署，测试，发布
    - 灵活组合
    - 可扩展性
        - 根据不同负载情况可以横向扩展
    - 技术异构
        - 对外接口不变，技术可以随意切换
    - 高可靠
        - 单个服务出错不会影响其他
- 缺点
    - 服务部署复杂
    - 调用链复杂

### 容器化

`Docker`

### 容器编排

用于容器化应用的自动化部署，扩展和管理
`K8S` 采用是 `Master-Worker` 架构模式。其中，`Master`
是最重要的节点，部署了大量核心组件，这些组件共同构成了 `Control Plane` (控制面板)。其中 `Worker` 就是 `Node Cluster`
节点集群，`Node` 就是计算资源，可以是物理机或者虚拟机。

##### `Master` 节点组件

- `Kube API Server`
    - 资源操作的唯一入口，提供认证，授权，访问控制，`API` 注册等
- `Kube Scheduler`
    - 负责资源的调度，按照预定的调度策略将 `Pod` 调度到对应机器
- `Kube Controller Manager`
    - 负责维护集群状态，故障检测，自动扩展，滚动更新等
- `Cloud Controller Manager`
    - `1.6+` 与基础云提供商交互
- `Etcd`
    - 分布式 `k-v` 存储，独立于 `K8S` 主要存储关键元数据，支持水平扩容

##### `Worker` 节点组件

- `Kubelet`
    - 负责维持容器的生命周期，同时负责 `volume（CVI）` 和 网络 `CNI`
- `kube-proxy`
    - 每个节点上运行的网络代理，维护节点上的网络规则，允许从集群内部或者外部网络与 `Pod` 进行网络通信
- `Container Runtime`
    - 负责镜像管理以及 `Pod` 和容器真正运行 `CRI`

##### `UI dashboard`

官方提供的 `web` 控制面板，可以对集群进行各种控制，直接与 `API Server` 进行交互，暴露出来的可视化接口

##### `Kubelet`

客户端工具，提供了大量的子命令

### `K8S` 核心资源

对象

- `Deployment`
- `Pod`
- `Service`

##### 描述文件

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: nginx
  labels:
    name: nginx
spec:
# ...
```

- `apiVersion` 和 `kind` 共同决定配置文件应该由谁来处理，前者描述文件使用的 `API` 组，后者表示资源类型
    - 此处表示 `api/v1` 中的 `Pod` 类型对象
- `metadata`
    - 该对象的元数据
    - `name`
        - 必需是 `namespace` 下面的唯一，主要用来筛选，是对象的唯一标识
    - `namespace`
    - `labels`
    - `annotations`

##### `Pod`

`K8S` 中运行的最小，最简单的计算单元；可以指定运行多个容器。可以挂载 `volume` 来实现部署有状态的服务

##### `Deployment`

一般来说不会直接部署 `Pod`, 而是部署一个 `Deployment` 或者 `StatefulSet` 之类的对象

`Deployment` 一般是无状态的服务；`StatefulSet` 是有状态的服务，会使用 `volume` 来持久化数据

```yaml
apiVersion: apps/v1 # for versions before 1.9.0 use apps/v1beta2
kind: Deployment
metadata:
  name: my-nginx
spec:
  selector:
    matchLabels:
      run: my-nginx
  replicas: 2
  template:
    metadata:
      labels:
        run: my-nginx
    spec:
      containers:
        - name: my-nginx
          image: nginx
          ports:
            - containerPort: 80
```

##### `Service`

常用的对象，它的作用是作为一组 `Pod` 的负载均衡器，利用 `selector` 将 `Service` 和 `Pod` 关联起来

```yaml
apiVersion: v1
kind: Service
metadata:
  name: my-nginx
  labels:
    run: my-nginx
spec:
  ports:
    - port: 80
      protocol: TCP
  selector:
    run: my-nginx
```

### `CI/CD`

通过自动化的手段，快速执行代码检查，测试，构建，部署等任务

- `CI`
    - 持续集成
    - 频繁的将开发者的代码合并到主干，代码开发后，`Push` 仓库， `CI` 工具立即对代码进行扫描，单元测试和构建，并将结果返回。持续集成后，会将代码合并到主干
- `CD`
    - 持续交付
    - 在持续集成的基础上，将构建后的产物自动部署在目标环境
- `CD`
    - 持续部署
    - 持续交付的基础上，代码经过测试环境自动部署到生产环境，整个流程不需要审核

### `DevOps`

目前落地的技术 `GitOps`，`ChatOps`，`AIOps` 实现运维和运营的高度自动化

### `Serverless`

无服务器，服务器的管理和资源对用户不可见，由平台开发商维护

- 无穷弹性计算能力
    - 根据请求水平扩容
- 零运维
    - 不需要维护服务器
- 伸缩能力
    - 根据指标敏感的弹性伸缩
- 按量收费

技术

- 云函数
- `Serverless` 容器
- 云原生数据库
- 应用

### 服务网格

随着微服务逐渐变多，应用程序可能变成成百上千互相调用的服务组成的大型应用程序，服务与服务之间通过内部或者外部网络进行通信

服务网格作为服务间通信的基础设施层是一种用于管理和监控微服务框架的网络基础设施层，将每个微服务需要实现的功能单独分离出来

- 功能
    - 服务发现
    - 负载均衡
    - 安全认证
    - 流量控制
    - 故障恢复功能
- 特点
    - 应用程序间通讯的中间层
    - 轻量级网络代理
    - 非入侵
    - 服务治理功能和服务本身解耦
        - 重试
        - 超时
        - 监控
        - 链路追踪
- 常用项目
    - `Istio`
        - 完全开源的服务网格，作为透明的一层接入现有的分布式应用中，提供服务治理等功能
        - 拥有集成日志，遥测和策略系统等接口
        - 实现原理
            - 每个服务都会被注入一个 `Sidecar` 组件，服务之间通讯是先通过 `Sidecar` 然后再将流量转发到另一个服务
            - 所有流量都会经过 `Sidecar`，所以通过它可以实现很多功能
                - 认证
                - 限流
                - 调用链
    - `Linkerd`
- 和微服务相比优势
    - 可观测性
        - 所有服务通讯都需要经过服务网格，此处可以捕获所有调用相关的指标数据
            - 来源
            - 目的
            - 协议
            - 状态码
    - 流量控制
        - 智能路由
        - 超时重试
    - 安全性
        - 认证
        - 加密

##### `Istio`

完全开源的服务网络，作为透明的一层接入现有的分布式应用程序中，提供数据治理等功能

主要实现原理，每一个服务会被注入一个 `Sidecar` 组件，服务之间通讯是先通过 `Sidecar`
然后再将流量转发到另一个服务;所有流量都会经过 `Sidecar`，因此可以实现许多功能，`认证`，`限流`，`调用链`

- 数据平台
    - 由 `Envoy Proxy`
- 控制平台
    - `Pilot`
        - 管理部署在 `Istio` 服务网格中的 `Envoy` 代理实例
        - 功能
            - 服务发现
            - 流量管理
            - 弹性
    - `Citadel`
        - 核心组件
        - 功能
            - 服务密钥
            - 数字证书管理
    - `Galley`
        - 提供支撑功能，配置中心
        - 功能
            - 校验进入网络配置信息的格式内容正确性，将这些配置信息提供给 `Pilot`

### 不可变基础设施

一个程序的实例，一旦被创建，就会进入到只读状态，如果想要修改，就只能重新创建一个实例

将基础设施视为代码，并使用自动化工具进行配置和管理

- 优点
    - 提高应用交付速率
        - 基础设施可以使用代码或者模板来设定，引入版本控制。确保测试版发布版本运行行为一致性
    - 快速扩展
        - 快速搭建一个新的基础设施环境
    - 更新和回滚

### 声明式 API

一种编程模型，开发人员描述所需要的结果来定义系统的状态，而不需要指定如何实现这些结果
系统或者框架负责解析和执行这些声明，根据声明描述，自动推导出实现的步骤和逻辑。开发人员更加专注定义目标和结果，不需要关注底层的实现细节

- 优点
    - 简洁
        - 通过描述性的语言和格式，简洁的定义想要的结果
    - 可读性
    - 可维护
        - 关注结果而不是实现细节，代码易于维护
- 使用
    - 常用于配置管理数据查询等
        - `Ansible`
        - `Terraform`