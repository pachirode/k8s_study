# Flannel

解决容器跨主机通信，实现了 `CNI` 规范

- `VXLAN`
- `host-gw`
- `UDP`

# UDP

最早支持的模式一种方式，性能比较差，目前已经被弃用

[流程图](./flannel.puml)

该方案使用时会在各个 `work` 节点上运行一个 `Flannel` 进程，同时创建一个 `Tunnel` 设备 `flannel0`

##### TUN

`TUN` 设备是一种虚拟的网络接口，工作在三层 `IP`
主要作用是在操作系统和用户应用程序之间传递 `IP` 包

##### Subnet

由 `Flannel` 管理的容器网络里，一台宿主机上的所有容器，都属于该宿主机被分配的子网上
子网和宿主机对应信息保存在 `Etcd` 中，通过容器 `IP` 确定子网，子网确定宿主机

### 执行流程

基于 `Flannel UDP` 模式需要三次用户态和和核心态之间的数据拷贝，同时还需要进行 `UDP` 封装和解封装

`VXLAN` 减少了用户态到内核态的切换次数

##### 容器到宿主机

容器中的进程发起 `IP` 包，源地址为 `100.96.1.2`，目标地址 `100.96.2.3`
这个包通过容器网关进入网桥，交给默认的路由规则，从而出现在宿主机上
> `IP` 包会被交给默认的路由规则，同一台宿主机上的通信，走的是直连模式

##### 宿主机到 flannel 0 设备

根据宿主机上的路由规则决定 `IP` 包的下一个目的地，进入到 `flannel0` 设备
`100.96.0.0/16 dev flannel0  proto kernel  scope link  src 100.96.1.0`

##### flannel 进程转发到 Node2

`flannel0` 设备收到 `IP` 包转发给 `flanned` 进程
进程根据这个 `IP` 包的目标地址去 `etcd` 中查询对应宿主机 `Node2`，封装一下发送给目标宿主机

##### 封装 UDP 包

`flanneld` 进程会把这个 `IP` 包直接封装在一个 `UDP` 包，源地址为 `Node 1`，目标地址为 `Node 2`

##### Node2 解析并处理 UDP 包

`flanneld` 进程接收到这个 `UDP` 包之后就可以从中解析出原先的 `IP` 包
解析之后将其发送给 `flannel0`，再转发给系统内核

##### 内核处理 IP 包

内核接收到这个 IP 包，通过本机路由表来查看这个 `IP` 包的下一步流向，最终转发到容器网络中

# VXLAN

`Virtual Extensible LAN` 虚拟可扩展局域网，`linux` 内核本身支持的虚拟化技术

在现有的三层网络之上，覆盖一层虚拟的，由内核 `VXLAN` 模块负责维护的二层网络，使得连接在这个网络上的主机之间可以像连接在同一个局域网上
[流程图](./vxlan.puml)

图中的 `flannel.1` 的设备就是 `VTEP`，既有 `IP` 地址，也有 `MAC` 地址

### VTEP

在宿主机上设置一个特殊的网络设备，虚拟隧道端点
`VTEP` 和 `flanneld` 进程非常相似，他处理的对象为二层数据帧
所有的工作流程全部是在内核中实现的

### 路由

每台宿主机上的 `flanneld` 进程负责维护相关路由规则
当一个节点启动加入 `Flanneld` 网络，其他节点上的 `flanneld` 就会添加如下路由规则

```bash
Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
10.1.16.0       10.1.16.0       255.255.255.0   UG    0      0        0 flannel.1
# 这条规则的意思是：凡是发往 10.1.16.0/24 网段的 IP 包，都需要经过 flannel.1 设备发出，并且，它最后被发往的网关地址 10.1.16.0
```

> 通过路由规则指定网络中其他 `flanneld` 节点

### ARP

`flanneld` 进程启动时，会自动把当前节点上的 `ARP` 记录发送给当前的 `flanneld` 网络中的其他节点
后续 `IP` 包用到的 `MAC` 地址从此处获取

### 网桥设备

`flanneld` 还需要扮演网桥设备，在二层网络进行 `UDP` 包的转发
网桥转发数据来源于 `FDB` 的转发数据库，`flanneld` 进程来维护这个数据库

### 执行流程

##### 容器到宿主机到 flannel1 设备

容器发出请求这个 `IP` 包，会根据容器内的规则，出现在 `docker0` 网桥
被路由到本机 `flannel1` 设备，进入隧道口，`VXLAN` 开始查找出口，即目标宿主机的 `VTEP` 设备

##### 封装 2 层数据帧

源 `VETP` 设备收到 `IP` 包在其上面添加了一个目的 `MAC` 地址，封装成一个二层数据帧，发送给目标设备

> 二层网络是虚拟出来的，需要自己处理封包逻辑

##### 数据帧再次封装，通过 UDP 发送

内核把内部数据帧进一步封装成普通数据帧便于网络间的传送，通过宿主机网卡进行传输

> 内核封装内部数据帧，会添加一个特殊的 `VXLAN` 头

##### flannel1 设备转发 UDP

##### 数组及拆包

# host-gw

选择 `flannel` 使用模式之后，宿主机会创建一条规则

```bash
# 所有属于目标网段的 IP 包，会经过本机 eth0 设备发出，并且下一跳地址为 10.168.0.3
10.244.1.0/24 via 10.168.0.3 dev eth0
```

该模式的工作原理就是将每个子网的下一跳，设置成子网的宿主机 `IP`，宿主机充当了容器通信线路里面的网关角色
`flannel` 只需要 `Watch` 这些数据，然后实时更新路由表即可
> 这种模式可以避免封包解包

[calico](./calico.md)